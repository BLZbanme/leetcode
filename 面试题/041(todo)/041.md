# [面试题41. 数据流中的中位数](https://leetcode-cn.com/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/)

如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。

例如，

[2,3,4] 的中位数是 3

[2,3] 的中位数是 (2 + 3) / 2 = 2.5

设计一个支持以下两种操作的数据结构：

void addNum(int num) - 从数据流中添加一个整数到数据结构中。
double findMedian() - 返回目前所有元素的中位数。
示例 1：

输入：
["MedianFinder","addNum","addNum","findMedian","addNum","findMedian"]
[[],[1],[2],[],[3],[]]
输出：[null,null,null,1.50000,null,2.00000]
示例 2：

输入：
["MedianFinder","addNum","findMedian","addNum","findMedian"]
[[],[2],[],[3],[]]
输出：[null,null,2.00000,null,2.50000]


限制：

最多会对 addNum、findMedia进行 50000 次调用。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof



##### 2020.06.18

##### 我的方法

构造函数中存储一个数组，这个数组是升序的。

每次插入新值时，二分查找找到这个值应该插入的位置。

**注：**标准二分查找可以找到比当前值小的最后一个下标的值。

```javascript
/**
 * initialize your data structure here.
 */
var MedianFinder = function() {
    this.priorityQueue = [];
};

/** 
 * @param {number} num
 * @return {void}
 */
MedianFinder.prototype.addNum = function(num) {
    if (!this.priorityQueue.length) {
        this.priorityQueue.push(num);
    }
    else {
        let index = binarySearch(this.priorityQueue, num);
        this.priorityQueue.splice(index, 0, num);
    }
};

function binarySearch(arr, val) {
    let lo = 0;
    let hi = arr.length;
    while (lo <= hi) {
        let mid = lo + ((hi - lo) >> 1);
        if (arr[mid] === val) {
            return mid;
        }
        else if (arr[mid] < val) {
            lo = mid + 1;
        }
        else {
            hi = mid - 1;
        }
    }
    return lo;
}

/**
 * @return {number}
 */
MedianFinder.prototype.findMedian = function() {
    if (this.priorityQueue.length % 2) {
        return this.priorityQueue[(this.priorityQueue.length - 1) / 2];
    }
    else {
        return (this.priorityQueue[this.priorityQueue.length / 2 - 1] 
            + this.priorityQueue[this.priorityQueue.length / 2]) / 2;
    }
};
```

##### 标准二分查找

```javascript
function binarySearch(arr, val) {
    let lo = 0;
    let hi = arr.length;
    while (lo <= hi) {
        let mid = lo + ((hi - lo) >> 1);
        if (arr[mid] === val) {
            return mid;
        }
        else if (arr[mid] < val) {
            lo = mid + 1;
        }
        else {
            hi = mid - 1;
        }
    }
    return lo;
}
```



#### 别人的方法：（未完待续）

